# 一、JavaScript概要

## 1. 为什么要学习JavaScript？

![01](/images/js/01/01.png)

- **HTML**是一种标记语言，用来结构化我们的网页内容并赋予内容含义，例如定义段落、标题，或在页面中嵌入图片和视频。**( 决定看到什么 )**。

- **CSS**是一种样式规则语言，可将样式应用于 HTML 内容， 例如设置背景颜色和字体，在多个列中布局内容。 **( 决定好不好看 )**。

- **JavaScript**是一种脚本语言，可以用来创建动态更新的内容，控制多媒体，制作图像动画，还有很多。

  这三层依次建立，秩序井然。**(实现业务逻辑和页面控制( 决定功能 )**。

案例：淘宝网二级菜单

## 2.  JavaScript应用场景

1. 表单验证
2. 网页动态效果（轮播，漂浮的广告）
3. 记住用户名字和密码
4. 游戏开发-经典案例俄罗斯方块
5. 页面中所有的能动的效果都是js来实现的

## 3. 什么是JavaScript

![02](/images/js/01/02.png)

官方解释：JavaScript 是一种**跨平台**的**脚本**语言。

> 平台：一般指的是运行环境，这里指的是操作系统
>
> 跨平台：就是在很多种操作系统中都可以运行

![18](/images/js/01/18.png)

> 脚本语言：特点是不能独立运行，需要依赖于网页。
>

ps：JavaScript程序的运行离不开HTML，HTML的运行离不开浏览器。

![19](/images/js/01/19.png)


​	JavaScript是一种属于网络的脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。

作为一个Web开发师，如果你想提供漂亮的网页、令用户满意的上网体验，JavaScript是必不可少的工具。

## 4. JavaScript历史

1. 1995 年 2 月，Netscape 公司发布 Netscape Navigator 2 浏览器，并在这个浏览器中免费提供了一个开发工具——LiveScript**（开发人员：布莱登爱奇：开发设计理念：跟java类似，比java简单,非专业人员也能很快上手）**。由于当时 Java 比较流行，Netscape 便把 LiveScript 改名为 JavaScript，这也是最初的 JavaScript 1.0 版本。
2. 由于 JavaScript 1.0 很受欢迎，Netscape 在 Netscape Navigator 3 中又发布了 JavaScript 1.1 版本。不久，微软在 Internet Explorer 3 中也加入了脚本编程功能。为了避免与 Netscape 的 JavaScript 产生纠纷，微软特意将其命名为 JScript。
3. 1997 年，欧洲计算机制造商协会（ECMA）以 JavaScript 1.1 为基础制订了脚本语言标准——ECMA-262，并命名为 ECMAScript。
4. 1998 年，国际标准化组织和国际电工委员会（ISO/IEC）采用了 ECMAScript 标准（即 ISO/IEC-16262）。自此，浏览器厂商就以 ECMAScript 作为各自 JavaScript 实现的规范标准。JavaScript 正式从各自为政走向了规范统一。

## 5. ECMAScript 起源

1997 年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了脚本语言的实现标准，并将这种语言命名为 ECMAScript。这个版本就是 ECMAScript 1.0 版。

之所以不叫 JavaScript，主要有以下两个原因：

- 商标限制。Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法使用 JavaScript 这个名字，而且 JavaScript 己经被 Netscape 公司注册为商标。
- 体现公益性。该标准的制订者是 ECMA 组织，而不是 Netscape 公司，这样有利于确保规范的开放性和中立性。

简单概括，ECMAScript 是 JavaScript 语言的规范标准，JavaScript 是 ECMAScript 的一种实现。注意，这两个词在一般语境中是可以互换的。

> ECMA：第一版的时候制定了制定了三个原则，（在设计上，js就不是专门针对浏览器的，可以支持多端运行）

> 第一个原则就是把所有和浏览器相关的代码全部删掉

> 第二点，支持unicode的标准。
>
> 第三点要求对象和平台无关。

## 6. ECMAScript 版本

1. 1998 年 6 月，ECMAScript 2.0 版发布。

2. 1999 年 12 月，ECMAScript 3.0 版发布，并成为 JavaScript 的通用标准，获得广泛支持。

3. 2007 年 10 月，ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级。由于 4.0 版的目标过于激进，各方对于是否通过这个标准产生了严重分歧。

4. 2008 年 7月，ECMA 中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分发布为 ECMAScript 3.1。不久，ECMAScript 3.1 改名为 ECMAScript 5。

5. 2009 年 12 月，ECMAScript 5.0 版正式发布。

6. 2011 年 6 月，ECMAScript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。

7. 2013 年 12 月，ECMAScript 6 版草案发布。

8. 2015 年 6 月，ECMAScript 6 发布正式版本，并更名为 ECMAScript 2015 。Mozilla 在这个标准的基础上推出了 JavaScript 2.0。

9. 从此以后，JavaScript 开始以年份命名，新版本将按照 “ECMAScript+年份” 的形式发布。目前最新 版本为 ECMAScript 2018，于 2018 年 7 月正式发布。

   

## 7. 浏览器支持

目前 5 大主流浏览器都支持 ECMAScript 5，具体说明如下：

- IE 9+
- Chrome 13+
- Firefox 4+
- Safari 5.1+
- Opera 11.60+

![20](/images/js/01/20.png)



## 8.浏览器执行 JS 简介

![1667724053648](/images/js/01/1667724053648.png)



> 浏览器本身并不会执行js代码，而是通过内置JavaScript引擎（解释器）来执行js代码，js引擎执行代码时逐行解释每一句源码（转换为机器语言）然后由计算机去执行，所以JavaScript语言归为脚本语言，会逐行解释执行

## 9. JavaScript 构成

![14](/images/js/01/14.png)

**ECMAScript - JavaScript的核心**

![1667724183014](/images/js/01/1667724183014.png)

实际上，一个完整的 JavaScript 实现由以下 3 个不同部分组成：

- 核心（ECMAScript）：语言核心部分。
- 文档对象模型（Document Object Model，DOM）：网页文档操作标准**（大小、位置、颜色等）**
- 浏览器对象模型（BOM）：客户端和浏览器窗口操作基础**(比如弹出框、控制浏览器跳转、获取分辨率等)**。

# 二、JavaScript基本使用

## 1. JavaScript初体验

js的引入方式行内样式有三种、行内式，嵌入样式、外部样式

**1、行内式**(可读性差，不方便阅读，多层引号嵌套容易弄混，一般不用)

```
<input type="button" value="按钮" onclick="alert('Hello World')" />
```



**2、js内部嵌入样式**

1. 在 HTML 中，JavaScript 代码必须位于` <script> `与 `</script>` 标签之间。

   ```html
   <script>
   	alert('这是我们的第一个js代码')；
   </script>
   ```

   >- script标签的属性
   >
   >- src :可选。表示包含要执行代码的外部文件。
   >
   >- type :可选 一般为 text/javascript。现代浏览器默认脚本类型是JavaScript，因此可以省略type
   >
   >  

   注释：旧的 JavaScript 例子也许会使用 type 属性：`<script type="text/javascript">`。

   注释：type 属性不是必需的。JavaScript 是 HTML 中的默认脚本语言。

   

2. `<body>`或者`<head>`中的JavaScript

   > 脚本可被放置与 HTML 页面的` <body>` 或 `<head> `部分中，或兼而有之。

   - `<body>`中的JavaScript

     ```html
     <!DOCTYPE html>
     <html>
         <head>
           	<title>body中的JavaScript</title>
       	</head>
         <body> 
             <script>
                    alert('body中的JavaScript');
             </script>
         </body>
     </html>
     ```

   - `<head>`中的JavaScript

     ```html
     <!DOCTYPE html>
     <html>
         <head>
             <script>
                 alert('<head>中的JavaScript');
             </script>
         </head>
         <body>
         </body>
     </html>
     ```

   - body 和 head 部分可同时有脚本:文件中可以在body和head部分同时存在脚本

     ```html
     <html>
         <head>
           <script>
           		alert(111);
           </script>
         </head>
         <body>
           <script>
           		alert(222);
           </script>
         </body>
     </html>
     ```

     思考：head和body中同时存在script文件会执行哪个？

   - 总结：js文件放到哪里更好？

     - 浏览器对html页面内容的加载是顺序加载，也就是在html页面中前面先加载。当浏览器加载html文件并解析到`<head>`时,`<body>`并没有被解析,浏览器会等到`<head>`中的js部分执行完再加载页面。
     
     - 如果把javascript放在head里的话，则先被解析,但这时候body还没有解析。（常规html结构都是head在前，body在后）如果head的js代码是需要传入一个参数（在body中调用该方法时，才会传入参数），并需调用该参数进行一系列的操作，那么这时候肯定就会报错，因为函数该参数未定undefined
     
     - 从JavaScript对页面下载性能方向考虑：由于脚本会阻塞其他资源的下载（如图片等）和页面渲染，直到脚本全部下载并执行完成后，页面的渲染才会继续，因此推荐将所有的`<script>`标签尽可能放到`<body>`标签的底部，以尽量减少对整个页面下载的影响。
     
       ```
       js运行机制(超级霸道)： 众人皆停，我独行。js是一种阻断式语言。
       ```
     
       

3. **引入外部脚本文件**

   - JS程序不仅可以直接写在HTML文档中，也可以放在JavaScript文件中。后缀名是.js。使用任何文本编辑器都可以编辑。
   - JS文件不能够单独运行，需要使用 `<script>`标签导入到网页中。
   - 内嵌引入和外链引入不能共用一个script标签，否则只会下载并执行外部JavaScript文件，嵌入代码被忽略。

   ```html
   1）创建一个js文件，名称为first.js
   2) 引入js文件
       <html>
           <head>
               <title></title>
           </head>
           <body>
             <script src='first.js'></script>
           </body>
       </html>
   ```

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>JS的引入</title>
   </head>
   <body>
      //内部引入
       <script>
           alert(1);
       </script>
       //外部引入
       <script src="./demo1.js"></script>
   </body>
   </html>
   ```

   

   注意：在外部文件中放置脚本有如下优势：

   - 分离了 HTML 和js代码
   - 使 HTML 和 JavaScript 更易于阅读和维护
   - 已缓存的 JavaScript 文件可加速页面加载

   思考：内部js代码和外部引用哪个优先级更高？





1. **延迟执行JS-defer**

   - `<script>`标签有一个布尔型属性defer，这个属性的用途是表明脚本在执行时不会影响页面的构造，也就是说，脚本会被延迟到整个页面都解析完成后再运行。
   - 因此在script元素中设置defer属性，相当于告诉浏览器立即下载，但是延迟执行
   - 如果页面中有多个延迟脚本，那么第一个延迟脚本会先于第二个延迟脚本执行
   - 适用于外部JS文件，不适用于script标签包含的脚本

   ```html
   <!-- 
       看运行结果
           1.head引入js
           2.body末尾引入js
           3.外部引入js+defer
   -->
   
   1）创建一个js文件，名称为first.js
   2) 引入js延迟文件
     <!DOCTYPE html>
     <html lang="en">
           <head>
               <meta charset="UTF-8">
               <title>Document</title>
                //外部引入js+defer,延迟执行
               <script src="./first.js" defer></script>
               <script>
                   alert("head引入js")
               </script>
           </head>
           <body>
               <script>
                   alert("body末尾引入js")
               </script>
           </body>
     </html>
   ```

2. 异步加载JS文件-async

   - 在默认情况下，网页都是同步加载外部 JavaScript文件的，在引入外部js文件时会阻塞dom的执行，为此在html4.01为script标签引入了async属性

   - 现在可以为`<script>`标签设置 async属性，让浏览器异步加载 Javascript文件，即表示应该立即下载脚本，但不应妨碍页面汇总的其它操作。只对外部脚本文件有效。

   - 因为是下载完立即执行，不能保证多个加载时的先后顺序，因此确保异步脚本之间互不依赖

     ```html
     1）创建一个js文件，名称为first.js
     2）引入js文件
         <!DOCTYPE html>
         <html lang="en">
             <head>
                 <meta charset="UTF-8">
                 <meta name="viewport" content="width=device-width, initial-scale=1.0">
                 <title>Document</title>
                 <script src="a.js" async></script>
             </head>
             <body>
                这是测试async的小案例，一jiao wulijiaojiao
             </body>
         </html>
     ```

扩展：async&defer

- 没有设置任何属性的script

  HTML文件将被解析，直到脚本文件被下载为止，同时将停止解析，发起请求去提取script文件（如果是外部文件）。下载并执行完成后将在恢复解析HTML。

  ![03](/images/js/01/03.png)

- 设置了defer属性

  设置defer属性会在HTML解析的同时下载script，并在完成HTML解析和script下载之后执行该文件，同时设置了defer的脚本会按照他们在文档里面出现的顺序执行。

  ![04](/images/js/01/04.png)

- 设置了async属性

  设置async属性会在HTML解析期间下载script文件，并在完成下载后暂停HTML解析器以执行该文件。

   ![05](/images/js/01/05.png)



## 2. JavaScript 输出

JavaScript 能够以不同方式“显示”数据：



| js输出                | 作用                               |
| --------------------- | ---------------------------------- |
| 使用 window.alert()   | 写入警告框                         |
| 使用 document.write() | 写入 HTML 输出                     |
| 使用 innerHTML        | 写入 HTML 元素                     |
| 使用 console.log()    | 写入浏览器控制台                   |
| 使用 prompt()         | 写入浏览器弹出输入框，用户可以输入 |



1. **alert**

   - JavaScript 语句是发给浏览器的命令。这些命令的作用是告诉浏览器要做的事情
   - alert() 语句让浏览器弹出一个窗口，窗口里的内容就是 alert() 中的内容

   ```html
   <!DOCTYPE html>
   <html>
     <body>
         <script>
           	//和alert是一样的，后续window对象时候讲解
         		window.alert('故事里的小黄花');
         </script>
     </body>
   </html> 
   ```

2. **document.write**

   1) 可以向HTML输出流中插入你传入的内容，浏览器会按着HTML元素依次顺序依次解析它们，并显示出来。

   ```html
   <!DOCTYPE html>
   <html>
     <body>
         <script>
         		document.write('从出生那年就飘着');
         </script>
     </body>
   </html> 
   ```

   2) 需要注意的是，如果在文档加载完成后（即HTML输出已完成），再使用document.write()方法来要求浏览器来解析你的内容，则浏览器就会重写整个document，导致最后的这个document.write()方法输出的内容会覆盖之前所有的内容

   ```html
   <!DOCTYPE html>
   <html>
   	<body>
   		<h6>淡黄的长裙</h6>
   		<h6>蓬松的头发</h6>
   		<button onclick="document.write('<h1>什么玩意儿</h1>')">试一试</button>
   	</body>
   </html>
   ```

3.  **innerHTML**

   id 属性定义 HTML 元素。innerHTML 属性定义 HTML 内容：

   ```html
   <!DOCTYPE html>
   <html>
   	<body>
   		<p id="demo"></p>
   		<script>
   			document.getElementById("demo").innerHTML = '我们的开始，是漫长的电影';
   		</script>
   	</body>
   </html> 
   ```

4.  **console.log**

   在浏览器中，您可使用 console.log() 方法来显示数据。

   请通过 F12 来激活浏览器控制台，并在菜单中选择“控制台”。

   ```html
   <!DOCTYPE html>
   <html>
   	<body>
   		<p id="demo"></p>
   		<script>
   			console.log('苍茫的天涯是的爱');
   		</script>
   	</body>
   </html> 
   ```


## 3. JavaScript语句

1. JavaScript 语句

   JavaScript 语句由以下构成：值、运算符、表达式、关键词和注释。

   ```js
   //我是一个注释，我属于js语句的一部分，我也是狠重要的
   var age = 1 + 17；
   ```

2. 分号;

   ```js
   a = 1;
   b = 2;
   c = a + b;
   ```

   如果有分号分隔，允许在同一行写多条语句：

   ```js
   a = 1; b = 2; c = a + b;
   ```

3. js的代码的行长度和折行

   为了达到最佳的可读性，程序员们常常喜欢把代码行控制在 80 个字符以内。

   可以在文本字符串中使用反斜杠对代码行进行换行

   ```html
   <!DOCTYPE html>
   <html>
   	<body>
   		<script>
   			document.write('我一路向北 \
   			离开有你的季节');
   		</script>
   	</body>
   </html> 
   ```

   不能像这样折行

   ```html
   <!DOCTYPE html>
   <html>
   	<body>
   		<script>
   			document.write \ 
   			("你好世界!");
   		</script>
   	</body>
   </html> 
   ```

4. js空白字符

   js会忽略多个空格。您可以向脚本添加空格，以增强可读性

   这两行是相等的：

   ```js
   var name = "emo";
   var name="emo"; 
   ```

   在运算符旁边（ = + - * / ）添加空格是个好习惯：

   ```js
   var x = y + z;
   ```



## 4. JavaScript注释

+ 单行注释

  单行注释以 // 开头。

  任何位于 // 与行末之间的文本都会被 JavaScript 忽略（不会执行）。

  ```html
  <!DOCTYPE html>
  <html>
  	<body>
  		<script>
  			// 我是一个注释
  			document.write("乘着风游荡在蓝天边");
  		</script>
  	</body>
  </html> 
  ```

+ 多行注释

  多行注释以 /* 开始，以 */ 结尾。

  ```html
  <!DOCTYPE html>
  <html>
  	<head>
  		<meta charset='utf-8'>
  	</head>
  	<body>
  		<script>
  			/* 
  			祭司神殿征战弓箭是谁的从前，
  			喜欢在人潮中你只属於我的那画面，
  			经过苏美女神身边，我以女神之名许愿，
  			思念像底格里斯河般的漫延，当古文明只剩下难解的语言，
  			传说就成了永垂不朽的诗篇
  			*/
  			document.write("乘着风游荡在蓝天边");
  		</script>
  	</body>
  </html> 
  ```

  ![1667724572289](/images/js/01/1667724572289.png)

+ 在行末使用注释

  ```html
  <!DOCTYPE html>
  <html>
  	<head>
  		<meta charset='utf-8'>
  	</head>
  	<body>
  		<script>
  			document.write("乘着风游荡在蓝天边"); //繁华如三千东流水，我只取一瓢爱了解
  		</script>
  	</body>
  </html> 
  ```


## 5. JavaScript变量

思考：下列代码有什么问题？

```js
		<script type="text/javascript">
				console.log(123456789012345678901234567890);
				console.log(123456789012345678901234567890);
				console.log(123456789012345678901234567890);
				console.log(123456789012345678901234567890);
				console.log(123456789012345678901234567890);
				console.log(123456789012345678901234567890);
				console.log(123456789012345678901234567890);
		</script>
```

1. **什么是js变量**

   ![1667724650847](/images/js/01/1667724650847.png)

   

   

   **2、变量在内存中的存储**

   ![1667724753869](/images/js/01/1667724753869.png)

   

   说明：

   - 变量相当于**容器**，值相当于容器内装的东西，而**变量名**就是容器上贴着的标签，通过标签可以找到变量，以便读、写它存储的值
   - ECMAScript 的变量是松散类型（弱类型，动态类型）的,所谓松散类型就是可以用来保存任何类型的数据

   

   **3声明变量**

   ```变量在使用时分为两步： 1. 声明变量   2. 赋值 
   变量在使用时分为两步： 1. 声明变量   2. 赋值
   
   格式：定义一个变量：`var x = 1；`
   x 叫做变量名，1 叫做字面量/值。
   ```

    

   #### 案例1**( 同时声明多个变量)**：

   在一个 var 语句中，可以声明一个或多个变量，也可以为变量赋值，**未赋值的变量初始化为 undefined**（未定义）值。当**声明多个变量**时，应使用**逗号**运算符分隔。

   ```html
   <!DOCTYPE html>
   <html>
   	<head>
   		<meta charset='utf-8'>
   	</head>
   	<body>
   		<script>
   			var a;  //声明一个变量
   			var a,b,c;  //声明多个变量
   			var b = 1; //声明并赋值
   			console.log(a);  //返回 undefined
   			console.log(b);  //返回 1
               
               同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。
   		</script>
   	</body>
   </html> 
   ```

   **案例2(更新变量)：在 js中，可以重复声明同一个变量，也可以反复初始化变量的值。**

   ```html
   <!DOCTYPE html>
   <html>
   	<head>
   		<meta charset='utf-8'>
   	</head>
   	<body>
   		<script>
   			var a = 1;
   			var a = 2;
   			var a = 3;
   			console.log(a);
                一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。
   		</script>
   	</body>
   </html> 
   ```

   #### 3. 声明变量特殊情况

   | **情况**                       | **说明**                | **结果**  |
   | ------------------------------ | ----------------------- | --------- |
   | var  age ; console.log (age);  | 只声明 不赋值           | undefined |
   | console.log(age)               | 不声明 不赋值  直接使用 | 报错      |
   | age   = 10; console.log (age); | 不声明 只赋值           | 10        |

   

   > 友情提示：
   >
   > ​		   在**非严格模式**下，JavaScript 允许不声明变量就直接为其赋值，这是因为 JavaScript 解释器能够自动隐式声明变量。隐式声明的变量总是作为全局变量使用。
   >
   > ​		   在**严格模式**下，变量必须先声明，然后才能使用。
   >
   > "use strict";
   > x = 3.14;       // 报错 (x 未定义)
   >
   > 

   **4、变量的命名规范**

   - 规则 - 必须遵守的，不遵守会报错

     - 由字母、数字、下划线、$符号组成，不能以数字开头
     - 不能是关键字和保留字，例如：for、while。
     - 区分大小写（Animal和 animal 是不同的变量）

   - 规范 - 建议遵守的，不遵守不会报错

     - 变量名必须有意义
     - 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：userName、userPassword

     

   - js标识符

     系统征用的有特殊功能的单词.

     ![15](/images/js/01/15.png)

     - 标识符指的是变量、函数、属性的名字，或者函数的参数。

     - 标识符命名规范

       - 第一个字符必须是一个字母、下划线（_）或一个美元符号（$），其他字符可以是字母、下划线、美元符号或数字

       - 不能含有空格 不能以关键字或保留字命名

       - 保留关键字

         ![06](/images/js/01/06.png)

         *标记的关键字是 ECMAScript5 中新添加的。

       - 应该避免使用 JavaScript 内置的对象、属性和方法的名称作为 Javascript 的变量或函数名：

         ![07](/images/js/01/07.png)

   - 命名规范

     标识符命名要做到顾名思义。

     > 起一个有意义的名字，尽量做到看一眼就知道是什么意思(提高代码可 读性) 比如: 名字 就定义为 name , 定义学生 用 student

     ```js
     a = "zhangsan"  # bad
     username = "zhangsan"  # good
     b = 23   # bad
     age = 23 # good
     ```

     遵守一定的命名规范。

     - 驼峰命名法，又分为大驼峰命名法和小驼峰命名法

     ![16](/images/js/01/16.png)

     - 小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog
     - 大驼峰式命名法（upper camel case）： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName.
     - 下划线  user_name

   - 下面哪些变量名不合法

     ```
     1
     18age
     $name
     _sex
     &sex
     theworld  theWorld
     ```

   

2. 赋值变量

   + 使用等号`=`运算符可以为变量赋值，等号左侧为变量，右侧为被赋的值。

   ```html
   <!DOCTYPE html>
   <html>
   	<head>
         这是一个赋值变量的一个案例
   	</head>
   	<body>
   		<script>
   			var name = 'Barry';
   			console.log(name);
   		</script>
   	</body>
   </html> 
   ```

   - 变量提升

     JavaScript 在预编译期会先预处理声明的变量

     ```html
     <!DOCTYPE html>
     <html>
     	<head>
     		<meta charset='utf-8'>
     	</head>
     	<body>
     		<script>
     			console.log(a_name);
     			a_name = 'Barry'
     			console.log(a_name);
     			var a_name;
     		</script>
     	</body>
     </html> 
     ```

     注意：声明变量放在最后，赋值操作放在前面。由于 JavaScript 在预编译期已经对变量声明语句进行了预解析，所以第一行代码读取变量值时不会抛出异常，而是返回未初始化的值 undefined。第三行代码是在赋值操作之后读取，故显示为Barry。JavaScript 引擎的解析方式是：先解析代码，获取所有被声明的变量，然后再一行一行地运行。 这样，所有声明的变量都会被提升到代码的头部，这就叫作变量提升。

   - 练习1：看看结果是什么？

     ```html
     <!DOCTYPE html>
     <html>
     	<head>
     		<meta charset='utf-8'>
     	</head>
     	<body>
     		<script>
     			console.log(a);
     			var a = 100;
     			console.log(a);
     		</script>
     	</body>
     </html> 
     ```

   - 练习2：将两个变量a,b的值交换，var a = 1; var b = 2;

     方案1：

     ```html
     <!DOCTYPE html>
     <html>
     	<head>
     		<meta charset='utf-8'>
     	</head>
     	<body>
     		<script>
     			var a = 1,
     				b = 2,
     				tmp;
     			tmp = a;
     			a = b;
     			b = tmp;
     			console.log(a);
     			console.log(b);
     		</script>
     	</body>
     </html> 
     ```

     方案2：

     ```html
     <!DOCTYPE html>
     <html>
     	<head>
     		<meta charset='utf-8'>
     	</head>
     	<body>
     		<script>
     			var a = 1,
     				b = 2;
     			a = a + b;
     			b = a - b;
     			a = a - b;
     			console.log(a);
     			console.log(b);
     		</script>
     	</body>
     </html> 
     ```

![1667725155126](/images/js/01/1667725155126.png)









## 6. JavaScript的变量类型

- ## 6-1. 为什么需要数据类型？

  

  > 计算的本质呢是对值进行操作，那么这个值无论是参与计算的值，还是说经过计算得到的这个值，我们在计算机当中有一个统一的名称比较数据。
  >
  > 那作为一门计算机的语言来讲，对吧要处理大量的数据?
  > 对吧，这是我们大家都知道的这个计算机的语言，它其实就是对各种数据进行处理，那如果你想更好地去处理这个数据的话，你就要把这个数据分门别类的给他归纳出来啊。
  > 就像我们这个图书馆一样，你要把不同类的书啊分门别类的归他归纳出来，然后放到不同的位置，这样你找起来就好找了，对吧。
  >
  > 
  >
  > 在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。
  > 简单来说，数据类型就是数据的类别型号。比如姓名`“张三”`，年龄`18`，这些数据的类型是不一样的。
  >
  > 

  ## 6-2. JavaScript的数据类型分为两种：

  - **值类型(基本类型)**：

  - 字符串（String）、数字(Number)、布尔(Boolean)、未定义（Undefined）、空（Null）、Symbol。

    > **注：**Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。

  - **引用数据类型**：对象(Object)、数组(Array)、函数(Function)。

## 扩展：[JS中基本类型和对象的区别]

作者：付婉丽

需要理解基本类型和对象的区别就得介绍另一个东西，JS引擎底层存储它们的方式。JS引擎底层将分配到的内存分为代码区和数据区，代码主要用来存储变量名，而赋值的数据则存储在数据区，而数据区又分为Stack栈内存和Heap堆内存。

- Stack栈内存主要用于存储基本数据类型以及对象的Heap地址。
- Heap堆内存存储对象。
  所以，基本类型和对象的存储是不同的。这一区别关系到数据的使用及改变。简单的说，基本类型数据是使用拷贝存储的，一个数据赋值给一个或多个变量是通过拷贝的，也就是说改变它们的赋值并不会影响其他声明的value数据。
  而对象则不同，对象并不会拷贝存储，在给声明赋值时拷贝的只是Heap内存地址，而并不真正拷贝对象，所以在之后改变对象内属性时，对指向同一对象的声明都会有影响，下面看几个例子。

 var a = 1; var b = a; b = 2;
 上面`a`的值仍然是`1`，因为基本数据类型是通过拷贝存储的。
 var a = {name: 1}; var b = a; b.name = 2;
 此时再使用`a.name`得到的是`2`，因为声明`a`、`b`只是拥有同一对象的相同Heap地址。通过直观的内存图能更好地理解。

![1667725693284](/images/js/01/1667725693284.png)



 内存图

 从图上就能看出，c、d指向的是同一个对象。另外，如果不是改变对象的属性，而是赋值另一个对象则不会对其他变量产生影响（即使两个对象内部完全相同，也仍然是不同对象）。
 深复制和浅复制
 深浅复制就是基于底层存储数据方式的不同产生的，基本类型之间的赋值，变化都属于深复制，而对对象的引用则属于浅复制。
 另外，如果一个对象失去了引用，即没有变量引用它，那么浏览器就会自动垃圾回收数据



## typeof 操作符（检测基本数据类型）

我们需要有一种手段来检测给定变量的数据类型：

- typeof 就是负责提供这方面信息的操作符，格式为 `typeof（a）`或` typeof a` ；

- typeof **检测值的数据类型就是string类型**，如果**两次typeof**，结果都是**字符串类型**

- 有些时候 typeof 操作符会返回一些令人迷惑但技术上却正确的值

  - 把**null归为Object**类型，而不是作为特殊的值（历史遗留bug）

    `  在JS中进行数据底层存储的时候是用二进制存储的，这是一定的，而且它的前三位是代表存储的数据类型，而000是代表object类型也就是引用类型的数据。而null正好全是0，所以它巧妙的符合object类型的存储格式，所以在typeof检测的时候，它才会输出object。`

    

  - 把**函数归为Function类型**，而不是Object类型的一个子类

```
// 声明一个变量a，值为：3
// 声明一个变量b，值为：null
// 声明一个变量c，值为："Hello!"
// 声明一个变量d，值为：true
// 声明一个变量e，不赋值
// 声明一个变量f，值为""
var a = 3;
var b = null;
var c = "hello";
var d = true;
var e ;
var f = "";
var g = [1,2,3,4];//数组
var h = function(){};//函数
```

```
//检测上一个案例的变量
console.log(typeof a);//number
console.log(typeof (b));//object
console.log(typeof (c));//string
console.log(typeof (d));//boolean
console.log(typeof (e));//undefined
console.log(typeof (f));//string
console.log(typeof (g));//object
console.log(typeof (h));//function  
```



## 数据类型的基本使用

### 字符串

**1、字符串的书写**

1、字符串可以是引号中的任意文本。您可以使用单引号或双引号：

```
- var name = "张三"`
- `var name = '李四'`
```

2、如果引号中间什么都不写 代表的是空字符串

```
 var str1 = ''; 
```

3、不可以一个单引号和一个双引号

```
-  var str4 = 'china";
- var str5 = "';
```

4、双引号不可以套双引号 因为它就近匹配

```
 var str6 = ""haihaihai"";
```

5、单引号不可以套单引号  因为它就近匹配

```
 var str7 = ''山东菏泽曹县'';
```

6、分清变量名和字符串数据

```
 var name = "小红";
 console.log(name, "name");
 //   第一个是变量名，第二个是name字符串数据
```



**2、字符串换行**

 (1)书写的时候可以进行换行

```
 var str = "一人我饮酒醉，\
            醉把那佳人成双对\
            ";
      console.log(str);
```

(2)在输出的时候 需要换行

```
var str1 = "两眼是独相随，\n只求他日成双对";
      console.log(str1);
```

（3）反斜杠是不会显示的  所以如果我们需要显示反斜杠的话

```
就可以在反斜杠前面再加一个反斜杠
      var str2 = "娇女我\\轻抚琴";
      console.log(str2);
```

（4）字符串是有顺序的  从前到后

```
       01234
      var str3 = "hello";
      console.log(str3[0]);
      console.log(str3[1]);
      console.log(str3[2]);
      console.log(str3[3]);
      console.log(str3[4]);
```

**3、将原本字符的含义进行转换** 

```
  var str = "\"";
            console.log(str);

            var str2 = '\'';
            console.log(str2);

            var str3 = '\你好';
            console.log(str3);

            var str4 = '\\';
            console.log(str4);
```



### 数字

在js中 无论是整数还是小数  那么都统称为number类型

JavaScript 只有一种数字类型。数字可以带小数点，也可以不带：

+ 整数：
  + `var a = 1;`
+ 浮点数：
  + `var a = 1.2;`

科学计数法

+ `var a = 123e5; var b = Number.MAX_VALUE`
+ `var a = 123e-5; var b = Number.MIN_VALUE`
+ 

### **布尔**

> 思考：什么时候会定义变量的时候 把该数据类型定义为boolean
>
> 这个变量只有2个结果的时候 我们可以使用boolean
>
>eg:性别   选中未选中

布尔（逻辑）只能有两个值：true 或 false。

+ `var b = true`

+ `var b = false`

  

### Undefined

就是声明了变量 但是没有赋值的时候 我们会返回undefined

+ `var u；`

  

### null


1. 如果想将一个对象 进行删除 那么我们就会将这个变量的值设置为null
   + `var n = null`
   + 类型是object，用来表示一个空的对象






## 7. JavaScript的变量类型高级

1. 字符串

   JavaScript字符串(String)就是由零个或多个**Unicode字符**组成的字符序列。零个字符表示空字符串。

   ascii码中：a  97     A   65    0    48

   + 字符串字面量/字符串直接量

     + 字符串必须包含在单引号或双引号中
     + 如果字符串包含在双引号中,则字符串内可以包含单引号;反之,也可以在单引号中包含双引号
     + 在ECMAScript 3中,字符串必须在一行内表示,换行表示是不允许的，如果要换行显示字符串,可以在字符串中添加换行符(\n)
     + 在ECMAScript 5中,字符串允许多行表示.实现方法:在换行结尾处添加反斜杠(\\).反斜杠和换行符不作为字符串直接量的内容
     + 在字符串中插入特殊字符,需要使用转义字符\,如单引号,双引号等
     + 字符串中每个字符都有固定的位置.第1个字符的下标位置为0,第2个字符的下标位置为1...···以此类推,最后一个字符的下标位置是字符串长度减1

     ```html
      // 1.字符串定义的格式
                 //   a.可以使用单引号和双引号
                 //   b.不可以一单一双
                 //   c.不可以 单套单 双套双
                 //   d.可以单套双  双套单
     
                 // 2.转义字符
                 //   \  就是让之前的符号失去意义
     
                 // 3.换行字符
                  //   \在编写代码的时候可以进行换行编写   
                 //   \n 在打印的时候可以进行换行
     
                 // 4.字符序列
                // 字符串中的每一个字符都是有顺序的  默认是从0开始 
     ```


   + 转义字符

     + 转义字符是字符的一种间接表示方式。在特殊语境中,无法直接使用字符自身

       ```js
       var str = "请看\"这个是一个双引号";
       console.log(str);
       ```

     + 如果在一个正常字符前添加反斜杠,JavaScript会忽略该反斜杠

       ```html
       <!DOCTYPE html>
       <html>
       	<head>
       		<meta charset='utf-8'>
       	</head>
       	<body>
       		<script>
       			// 在某些特殊的语境中 无法使用的字符 我们就需要转义来将
                   // 进行输出
                   var str = '\'哈哈哈';
                   console.log(str);

                   // 在正常的字符串里面数据的前面添加一个转义字符 则会被忽略
                   var str1 = '今天\你过的好吗？';
                   console.log(str1);

                   // 如果我要想一个反斜线 怎么做？
                   var str2 = '今天\\你过的好吗？';
                   console.log(str2);
       		</script>
       	</body>
       </html> 
       ```

   + 字符串操作

     + 借助String类型的原型方法,可以灵活操作字符串（后面各章节中详细介绍）

     + 在JavaScript中,可以使用加号(+)运算符连接两个字符串

     + 使用字符串的length属性获取字符串的字符个数(长度）

     + 在ES5中，字符串可以作为只读数组使用，可以通过中括号运算符添加下标访问某一个值。下标从0开始，最大位置的下标是length-1

       ```html
       <!DOCTYPE html>
       <html>
       	<head>
       		<meta charset='utf-8'>
       	</head>
       	<body>
       		<script>
       			var str = 'hello';

                   // string
                   // 字符串 + 字符串 ===》将字符串链接在一起了
                   console.log(str + 'kanghui');
                   // number
                   // 字符串 + 数字  ===》将数字和字符串链接在一起了
                   console.log(str + 5);
                   console.log(str + 1.5);
                   // boolean
                   // 字符串 + boolean ===》将true和字符串链接在一起了
                   console.log(str + true);
                   console.log(str + false);
                   // undefined
                   // 字符串 + undefined ===》将undefined和字符串在一起了
                   console.log(str + undefined);
                   // null
                   console.log(str + null);

                   // 综上所述：
                   // 在+号的两端 只要有一端是字符串 那么结果就是字符串
                   // 结果是拼接的结果
       		</script>
       	</body>
       </html> 
       ```

   + String方法

     String方法是可以将其他类型转换成字符串类型

     ```html
     <!DOCTYPE html>
     <html lang="en">
               <head>
                   <meta charset="UTF-8">
                   <title>Title</title>
               </head>
               <body>
                   <script>
                       // 强制类型转换

                 // string
                 // var str = 'abcd';
                 // 判断数据的数据类型
                 // console.log(typeof str);
                 // 将str强制类型转换为字符串
                 // var str_string = String(str);
                 // console.log(typeof str_string);

                 // number
                 // var str2 = 123;
                 // console.log(typeof str2);
                 // var str2_string = String(str2);
                 // console.log(typeof str2_string);
    
                 // boolean
                 // var str3 = true;
                 // console.log(typeof str3);
    
                 // var str3_string = String(str3);
                 // console.log(str3_string);
                 // console.log(typeof str3_string);


                 // undefined
                 // var str4 = undefined;
                 // console.log(typeof str4);
    
                 // var str4_string = String(str4);
                 // console.log(typeof str4_string);


                 // null  null就是null的类型 但是在判断null的时候
                 // 那么他显示的是object类型
                 var str5 = null;
                 console.log(typeof str5);
    
                 var str5_string = String(str5);
                 console.log(typeof str5_string);


                 // 总结：
                 // String方法可以将任意的数据类型转换为string
                // 一般应用场景 在于 后端给你传递过来的数据 如果不是
                // 你想要的string 那么就可以通过这个方法来实现你想要的数据
                   </script>
               </body>
     </html>
     ```

   + toString方法

     + 我们的代码中有+（加号）运算符的情况下，它在这种情况下（字符串 + 其它什么东西），会调用toString()方法，将其它类型的东西转化为字符串，再和原始字符串拼接成一个字符串
     + 除了null和undefined之外，其他的类型(数值、布尔、字符串)都有toString()方法，它返回相应值的
     + 字符串表现(并不修改原变量)。
     + 每个对象都有一个toString()方法。
     + 当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。

     ```html
     <!DOCTYPE html>
     <html lang="en">
           <head>
               <meta charset="UTF-8">
               <title>Title</title>
           </head>
           <body>
               <script>
                   // 思考：为什么加号的两端 只要有一端是字符串 那么结果就是
                 // 字符串呢?
                 // 如果在加号的两端一端有字符串了 那么另一端的数据就会调用
                 // toString 然后再进行拼接
                 // console.log('a' + 1);
                 // 1.toString() ===> '1'  再将'a' + '1' ==>'a1'

                 // 除了null和undefined之外，其他的数据类型的数据 都有toString方法
                 // 返回的是相应的值

                 // toString本身的意义也是将对相应的数据转换为字符串类型

                 // string
                 // console.log('a'.toString());

                 // number
                 // var a = 1;
                 // 判断了a.toString()的值的类型
                 // console.log(typeof a.toString());

                 // boolean
                 // var a = true;
                 // console.log(typeof a.toString());

                 // undefined
                 // undefined没有toString这个方法
                 // console.log(undefined.toString());

                 // null
                 // null没有toString方法
                 console.log(null.toString());
                   
                / 总结：
                 // 将其他的数据类型 变成字符串的方法
                 // （1）String()
                 // （2）toString()
                 // （3）将数据 + '';
               </script>
           </body>
     </html>
     ```

2. 数字

   数字（Number）也称为数值或者数

   当数字直接出现在程序中时，被称为数值直接量。在 JavaScript程序中，直接输入的任何数字都被视为数值直接量。

   > JavaScript 中的所有数字都是以 64 位浮点数形式存储，包括整数。例如，2 与 2.0 是同一个数。

   + 数字（Number）也称为数值或者数

     - 整数，浮点数值（数字直接量）
  - 八进制数（010、025）
    
     - 十六进制数（0xa、0x1c）
     
  - 二进制数
    
     - 科学计数法
     
  - Number.MIN_VALUE
    
     - Number.Max_VALUE
     
  - Infinity 无限大，不是具体数值
     - NaN

     ### [2、整数，浮点数值（数字直接量）](http://180.76.234.180/#/./JS基础/03.JS数据类型?id=整数，浮点数值（数字直接量）)

     当数字直接出现在程序中时候，被称为数字直接量 JS所有的数字都是以64位浮点数存储，所以2和2.0是同一个数字

     ```js
    var num1 = 19;//整数
     console.log(num1);
    
     var num2 = 18.11112;//浮点数
    console.log(num2);Copy to clipboardErrorCopied
    ```

     ### [3、八进制数](http://180.76.234.180/#/./JS基础/03.JS数据类型?id=八进制数)

     数字前加一个0,代表8进制数

     ```js
     var num3 = 010;//数字前加一个0 代表8进制数
     console.log(num3);//打印的是十进制  8
     ```
   
     ### [4、十六进制数](http://180.76.234.180/#/./JS基础/03.JS数据类型?id=十六进制数)
   
     数字前加上0x,代表十六进制数
   
     ```js
     var num4 = 0xff;//数字前加上0x 代表十六进制数
     console.log(num4);//255
     ```
    
     ### [5、二进制数(支持性不好，谨慎使用)](http://180.76.234.180/#/./JS基础/03.JS数据类型?id=二进制数支持性不好，谨慎使用)
    
     数字前加上0b,代表二进制数

     ```
 var num5 = 0b11;//数字前加上0b 代表二进制数
     console.log(num5);//3
     ```
    
      ### [6、科学计数法](http://180.76.234.180/#/./JS基础/03.JS数据类型?id=科学计数法)
    
    用E代表底数10,后边跟E的指数,可以是正负值
    
    ```js
    var num5 = 1.2E-7;
     console.log(num5);//1.2E-7
     console.log(num5+1);//1.00000012   运算以后
    ```
    
    ### [7、最大值最小值](http://180.76.234.180/#/./JS基础/03.JS数据类型?id=最大值最小值)
    
     在js中数字也是有最大值和最小值的支持的，如果超过最大值或最小值，就可能计算有误


```js
 // 在js中数字也是有最大值和最小值的支持的，如果超过最大值或最小值，就可能计算有误
  console.log(Number.MIN_VALUE);//5e-324  支持数字的最小值
  console.log(Number.MAX_VALUE);//1.7976931348623157e+308 

```
 ### [8、Infinity](http://180.76.234.180/#/./JS基础/03.JS数据类型?id=infinity)

 - 计算超出范围会得到无穷大(infinity)或者无穷小(-infinity)
  - 分母为0会构成无穷大Infinity 或负无穷大-Infinity
     - 关于Infinity的运算， 无法计算 加减乘除一个数字都是Infinity，Infinity和Infinity计算，加法乘法为Infinity，其他为NaN
     - Infinity和自身相等 其他比较正常

  ```js

     // 分母为0会构成无穷大Infinity 或负无穷大-Infinity
     var num6 = 5/0;
     console.log(num6);//Infinity
     
     var num7 = -5/0;
     console.log(num7);//-Infinity

 console.log(typeof (Infinity));//无穷大和无穷小都是属于number类型
     
  // 关于Infinity的运算， 无法计算 加减乘除一个数字都是Infinity，Infinity和Infinity计算，加法乘法为Infinity，其他为NaN
     console.log(Infinity + 1);//Infinity
     console.log(Infinity - 1);//Infinity
     console.log(Infinity - 1000000000000000000000);//Infinity
     console.log(Infinity - Infinity);//NaN
     console.log(Infinity * Infinity);//Infinity
  console.log(Infinity + Infinity);//Infinity
     console.log(Infinity / Infinity);//NaN
     
  ```

~~~js
 //Infinity和自身相等  其他比较正常
 console.log(Infinity > 1);//true
 console.log(Infinity < 1);//false
 console.log(Infinity == 1);//false
 console.log(Infinity > Infinity);//false
 console.log(Infinity == Infinity);//true
 console.log(Infinity < Infinity);//false
 console.log(Infinity > -Infinity);//trueCopy to clipboardErrorCopied
 ```
   
 ### [9、NaN](http://180.76.234.180/#/./JS基础/03.JS数据类型?id=nan)
   
 - NaN,即非数值(Not a Number)是一个特殊的数值
 - 这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)
 - aN特点：无论和谁比较都是fasle 无论和谁计算都是NaN
   
 ```js
 var num8 = "李沛华"-1;
 console.log(num8)//NaN
   // 一个字符串是不可以减一  理论行不通
   // js怕报错 所以返回了一个NaN
~~~

```js
  // NaN特点：无论和谁比较都是fasle  无论和谁计算都是NaN
​     console.log(NaN+1);//NaN
​     console.log(NaN>1);//fasle
​     console.log(NaN==1);//fasle
​     console.log(NaN<1);//fasleCopy to clipboardErrorCopied
​     
​        // 计算
​                 // 数值和NaN计算 除了+字符串之外 其余的全是NaN
​                 // +
​                 // console.log(n + 'abc');
​                 // console.log(n + 1);
​                 // console.log(n + true);
​                 // console.log(n + undefined);
​                 // console.log(n + null);
​                 // -
​                 // console.log(n - 'abc');
​                 // console.log(n - 1);
​                 // console.log(n - true);
​                 // console.log(n - undefined);
​                 // console.log(n - null);
​                 // *
​                 // console.log(n * 'abc');
​                 // console.log(n * 1);
​                 // console.log(n * true);
​                 // console.log(n * undefined);
​                 // console.log(n * null);
​                 // /
​                 // console.log(n / 'abc');
​                 // console.log(n / 1);
​                 // console.log(n / true);
​                 // console.log(n / undefined);
​                 // console.log(n / null);
​      // 比较
​                      // 任何和NAN的比较的结果都是false
​                      // string
​                      console.log(n > 'abc');
​                      console.log(n < 'abc');
​                      // number
​                      console.log(n > 1);
​                      console.log(n < 1);
​                      // boolean
​                      console.log(n > true);
​                      console.log(n < true);
​                      console.log(n < false);
​                      console.log(n > false);
​                      // undefined
​                      console.log(n > undefined);
​                      console.log(n < undefined);
​                      // null
​                      console.log(n > null);
​                      console.log(n < null);
​     
​                      // 总结：
​                      // 任何和NaN的计算结果都是NaN（字符串加法除外）
​                      // 任何和NaN的比较结果都是false
```



  ### [10、isNaN方法的使用](http://180.76.234.180/#/./JS基础/03.JS数据类型?id=isnan方法的使用)

```js
 - isNaN方法检测一个值是不是非纯数字 , 如果非纯数字就返回true 如果是纯数字就返回false
   
  <!DOCTYPE html>
      <html lang="en">
            <head>
                <meta charset="UTF-8">
                <title>Title</title>
            </head>
            <body>
                <script>
                        document.write(isNaN(123));
                        document.write(isNaN(-1.23));
                        document.write(isNaN(5-2));
                        document.write(isNaN(0));
                        document.write(isNaN("Hello"));
                        document.write(isNaN("2005/12/12"));
                </script>
            </body>
      </html>


```

### [11、浮点数溢出](http://180.76.234.180/#/./JS基础/03.JS数据类型?id=浮点数溢出)

 - 执行数值计算，要防止浮点数溢出，例如 0.1+0.2不等于0.3
 - 因为js执行二进制浮点数算术标准而导致的问题。
 - 解决方法：浮点数的证书运算是精确的，所以消除表现的问题可以通过指定精度来避免。比如（1+2）/10

> >        小数一般都用用二进制表示出来,但是有一些特殊的小数，像这个0.1，那0.2怕用二进制都表示不出来，如果你把0.1和0.2转换成二进制的话，那么它是一个无限循环的一个小数。是你这个数字的位数越长啊，就是越接近你所标志的这个0.1或者0.2，但是永远达不到啊，是这么一个关系，
> >
> >        原理：就是因为十进制转换到二进制，然后再转换成十进制啊。这个时候产生的一个误差，这个是计算机的一个运行原理造成的
> >
> >        举一个例子：
> >
> >        像我们父母这个年代，他们所用到的这个标识距离的长度单位，用尺计算，比如说就卖二尺步，有一天啊
> >
> >        你妈让你去。帮他买两根儿绳子啊，两根绳子，他是这么跟你说的。
> >        哎，你去帮我买两根绳子，
> >
> >        第一根绳子，我要一尺长的
> >
> >        第二根绳子，我要两尺长的
> >
> >        这样去买那么两根绳子，大家都知道在距离单位里头三尺等于—米，对吧，这个大家都知道三尺等于一米，那么让你买了这两根绳子，第一个叫—尺。
> >        第二个是两尺，那么很简单，第一个你要买1/3米，第二个你要买2/3米，对吧?
> >
> >        于是你就跑到卖绳子的这个店。
> >        你跟老板说我要一尺绳子，呃，要一根两尺的绳子，那老板肯定是不知道怎么怎么卖，对吧?他说，我的绳子就是按米卖的啊，你就告诉我你要多少米。
> >        这个时候你怎么去表达这件事情，你只能说我一个要0.3333米，一个要0.6666米，对吧，你要你要这么两根绳子?
> >        那么，不管你怎么说，这个数字你都无限的接近啊，这个一尺和两尺，但是你永远达不到永远的达不到你只能无限的接近。
> >        所以说，你最后买回来的这两根儿绳子啊，一个是好像是一尺的，一个好像是量尺的，但是永远达不到刚才我们说到的这个三尺，因为你每个里面都有偏差，这个就和我们刚才说到这个零点，一加0.2不等于0.3是一个道理。
>
>

   

3. 布尔

   布尔类型仅包含两个固定的值：`true`和`false`。其中`true`代表真，`false`代表假。

   在一些判断等操作中，需要使用布尔值

   ```html
   <!DOCTYPE html>
   <html lang="en">
         <head>
             <meta charset="UTF-8">
             <title>Title</title>
         </head>
         <body>
             <script>
                 // 布尔：强制类型转换
               // var a = true;
               // var b = false;
               // console.log(a);
               // console.log(b);

               // string
               // Boolean（字符串）的时候 判断字符串里面是否有内容
               // 如果有内容就是true 如果没有内容就是false
               // console.log(Boolean('abcd'));
               // console.log(Boolean(''));     //false
               // console.log(Boolean('       '));

               // number
               // Boolean(数值) 只要有数值都是true  但是0除外
               // console.log(Boolean(1));
               // console.log(Boolean(-1));
               // console.log(Boolean(1.1));
               // console.log(Boolean(-1.1));
               // console.log(Boolean(0));       //false

               // console.log(Boolean(Infinity));
               // console.log(Boolean(-Infinity));
               // console.log(Boolean(NaN));     //false

               // boolean
               // console.log(Boolean(true));
               // console.log(Boolean(false));   //false
               // undefined
               console.log(Boolean(undefined));  //false
               // null 
               console.log(Boolean(null));      //false

               // 哪几种情况是false的时候 千万要注意
               // （1）空串
               // （2）0   
               // （3）NaN
               // （4）false
               // （5）undefined
               // （6）null
             </script>
         </body>
   </html>
   ```

4. Undefined

   变量被声明了，但没有赋值时，就等于undefined

   我们不会对一个值设置undefined，一般都是出现错误的时候，才会被我们打印出来

   ```js
   //打印a的时候，找到a了 但是找不到a的值，所以返回一个undefined
   var a;
   console.log(a);
   console.log(a+1);//undefined+1  计算不了
   
   //不声明b，直接使用b，js直接报错  ReferenceError(引用错误)： b is not defined
   //说明完全没有找到b这个变量 代码报错停止运行
   console.log(b)
   ```

5. null

   - null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。
   - 从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测null时会返回"object"的原因

6. 扩展：


```js
  1. Undefined派生自Null，两者都是表示空缺值，转换成布尔值都是假值，可以相等
  2. 但是Undefined和Null属于两种不同的类型
  3. Undefined隐含着意外的空值，而Null隐含着意料之中的空值。因此设置一个变量、参数为空的时候，建议使用null而不是undefined
```

- 相同：

  ​    - 这两种数据类型只有一个值,null 和undefined没有方法

  ​    - 参与判断，都返回false

  不同

  ​    1、null是关键字，undefined不是关键字

  ​    2、null是一个特殊的对象，对象是空的，undefined其实是window的一个属性，属性undefined: undefined，

  检测数据是否存在undefined
  检测数据是否为空用null

- 建议：
  1、变量赋值 不要undefined要用null
  2、判断某个值是否存在，或者是否为空的时候， ==null  ，（后台返东西，不是空没有，就是null）



## 8. JavaScript判断数据类型

> 友情提示:
>
> 基本数据类型：String，、Number、Boolean、Undefined、Null、Symbol
>
> 引用数据类型 ：Object  数组  函数

1. typeof

   typeof可以识别出基本类型String，、Number、Boolean、Undefined、Symbol，但是不能识别null。不能识别引用数据类型，会把null、array、object统一归为object类型,但是可以识别出function。

   所以typeof可以用来识别一些基本类型

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>Title</title>
   </head>
   <body>
       <script>
           var bool = true;
           var num = 1;
           var str = 'abc';
           var und= undefined;
           var nul = null;
           var s1 = Symbol();

           console.log(typeof bool); //boolean
           console.log(typeof num);//number
           console.log(typeof str);//string
           console.log(typeof und);//undefined
           console.log(typeof nul);//object
           console.log(typeof s1); //symbol
       </script>
   </body>
   </html>
   ```

2. instanceof

   instanceof不能识别出基本的数据类型 String，、Number、Boolean、Undefined、Null、Symbol

   但是可以检测出引用类型，如array、object、function，同时对于是使用new声明的类型，它还可以检测出多层继承关系。

   判断某对象是否是某类  

   其实也很好理解，js的继承都是采用原型链来继承的。比如Dog  instanceof Animal ，其实就是看objA的原型链上是否有A的原型，而A的原型上保留A的constructor属性。

   所以instanceof一般用来检测对象类型，以及继承关系.

   ```html
   <!DOCTYPE html>
   <html lang="en">
           <head>
               <meta charset="UTF-8">
               <title>Title</title>
           </head>
           <body>
               <script>
                   var bool = true;
                   var num = 1;
                   var str = 'abc';
                   var und= undefined;
                   var nul = null;
                   var s1 = Symbol();

                   console.log(bool instanceof Boolean);// false
                   console.log(num instanceof Number);// false
                   console.log(str instanceof String);// false
                   console.log(und instanceof Object);// false
                   console.log(nul instanceof Object);// false
                   console.log(s1 instanceof Symbol);// false
               </script>
           </body>
   </html>
   ```

3. constructor

   null、undefined没有construstor方法，因此constructor不能判断undefined和null。

   ```html
   <!DOCTYPE html>
   <html lang="en">
         <head>
             <meta charset="UTF-8">
             <title>Title</title>
         </head>
         <body>
             <script>
                 var bool = true;
                 var num = 1;
                 var str = 'abc';
                 var und= undefined;
                 var nul = null;
                 var s1 = Symbol();

                 console.log(bool.constructor === Boolean);// true
                 console.log(num.constructor === Number);// true
                 console.log(str.constructor === String);// true
                 console.log(s1.constructor === Symbol);//true
             </script>
         </body>
   </html>
   ```

4. toString

   此方法可以相对较全的判断js的数据类型。

   ```html
   <!DOCTYPE html>
   <html lang="en">
         <head>
             <meta charset="UTF-8">
             <title>Title</title>
         </head>
         <body>
             <script>
                 var bool = true;
                 var num = 1;
                 var str = 'abc';
                 var und= undefined;
                 var nul = null;
                 var s1 = Symbol();

                 console.log(Object.prototype.toString.call(bool));//[object Boolean]
                 console.log(Object.prototype.toString.call(num));//[object Number]
                 console.log(Object.prototype.toString.call(str));//[object String]
                 console.log(Object.prototype.toString.call(und));//[object Undefined]
                 console.log(Object.prototype.toString.call(nul));//[object Null]
                 console.log(Object.prototype.toString.call(s1)); //[object Symbol]
             </script>
         </body>
   </html>
   ```

5. 总结：至于在项目中使用哪个判断，还是要看使用场景，具体的选择，一般基本的类型可以选择typeof，引用类型可以使用instanceof。


## 9. JavaScript数据类型转换

1. Number方法

   Number()方法 将其他类型转换成number类型 Number方法会返回一个转换后的值

   ```html
   <!DOCTYPE html>
   <html lang="en">
         <head>
             <meta charset="UTF-8">
             <title>Title</title>
         </head>
         <body>
             <script>
                 // string
               // console.log(Number('123'));
               // console.log(Number('-123'));
               // console.log(Number('1.23'));
               // console.log(Number('-1.23'));
               // console.log(Number('0'));    ---->0

               // 空字符串 Number转换之后是0
               // console.log(Number(''));     ----->0
               // 如果字符串中都是空格的话 那么结果就是0
               // console.log(Number('         '));----->0
               // NaN
               // console.log(Number('a'));
               // console.log(Number('李'));
               // console.log(Number('1a'));

               // number
               // console.log(Number(1));
               // console.log(Number(-1));
               // console.log(Number(1.1));
               // console.log(Number(-1.1));
               // console.log(Number(0));      ------>0
               // console.log(Number(NaN));
               console.log(Number(Infinity));
               // console.log(Number(Number.MAX_VALUE));
               // console.log(Number(Math.PI));

               // boolean
               // console.log(Number(true)); // 1
               // console.log(Number(false));// 0  ------>0

               // undefined  
               console.log(Number(undefined));

               // null
               console.log(Number(null));
             </script>
         </body>
   </html>
   ```

2. parseInt

   parseInt是一个全局方法,它可以把值转换为整数

   - 第1步,先解析位置0处的字符,如果不是有效数字,则直接返回 NaN.
   - 第2步,如果位置0处的字符是数字,或者可以转换为有效数字,则继续解析位置1处的字符,如果不是有效数字,则直接返回位置0处的有效数字。
   - 第3步,以此类推,按从左到右的顺序,逐个分析每个字符,直到发现非数字字符为止。
   - 第4步,parseInt()将把前面分析合法的数字字符全部转换为数值并返回。

   ```html
   <!DOCTYPE html>
   <html lang="en">
       <head>
           <meta charset="UTF-8">
           <title>Title</title>
       </head>
       <body>
           <script>
               // string
               console.log(parseInt('1'));
               console.log(parseInt('-1'));
               // parseInt解析整数  
               // 解析到第一个非数字的字符就停止
               console.log(parseInt('1.2'));
               console.log(parseInt('-1.2'));
               console.log(parseInt('0'));

               console.log(parseInt('1a2b3c'));
               console.log(parseInt('123a'));
               console.log(parseInt('a123'));

               // number
               console.log(parseInt(1));
               console.log(parseInt(-1));
               console.log(parseInt(1.2));
               console.log(parseInt(-1.2));
               console.log(parseInt(0));
               console.log(parseInt(NaN));
               console.log(parseInt(Infinity));

               // boolean
               console.log(parseInt(true));
               console.log(parseInt(false));

               // undefined
               console.log(parseInt(undefined));

               // null
               console.log(parseInt(null));
           </script>
       </body>
   </html>
   ```

3. parseFloat()也是一个全局方法，它可以把值转换成浮点数，即它能够识别第一个出现的小数点，而第二个小数点视为非法。解析过程和parseInt相同。

   ```html
   <!DOCTYPE html>
   <html lang="en">
       <head>
           <meta charset="UTF-8">
           <title>Title</title>
       </head>
       <body>
           <script>
               // string
               console.log(parseFloat('1'));
               console.log(parseFloat('-1'));
               console.log(parseFloat('1.2'));
               console.log(parseFloat('-1.2'));
               console.log(parseFloat('0'));

               console.log(parseFloat('1.2.3.4'));
               console.log(parseFloat('1.2a.3'));
               console.log(parseFloat('a1.2'));

               // number
               console.log(parseFloat(1));
               console.log(parseFloat(-1));
               console.log(parseFloat(1.3));
               console.log(parseFloat(-1.3));
               console.log(parseFloat(0));
               console.log(parseFloat(0.0));

               console.log(parseFloat(NaN));
               console.log(parseFloat(Infinity)); //Infinity

               // boolean
               console.log(parseFloat(true));
               console.log(parseFloat(false));

               // undefined
               console.log(parseFloat(undefined));

               // null
               console.log(parseFloat(null));
           </script>
       </body>
   </html>
   ```

4. 运算符转换

   如果变量乘以1，则变量会被JS自动转换成数值，如果无法转换成合法数值，则返回NaN

   ```html
   <!DOCTYPE html>
   <html lang="en">
       <head>
           <meta charset="UTF-8">
           <title>Title</title>
       </head>
       <body>
           <script>
               /*如果说变量乘以1  变量就会被自动隐式转换为数字类型，如果转不了就变成NaN*/
               var a = "1";
               console.log(a * 1);//number类型的  1
               var b = "1a";
               console.log(b * 1);//NaN

               /*减法也可以*/
               var c = "1";
               console.log(c - 0);//number类型的  1
               var d = "1a";
               console.log(d - 0);//NaN

               /*除1也可以*/
               var e = "1";
               console.log(e / 1);//number类型的  1
               var f = "1a";
               console.log(f / 1);//NaN
           </script>
       </body>
   </html>
   ```

## 10. JavaScript运算符

> JS中为我们定义了一套对数据进行运算的运算符,共定义了47个运算符。

### 1. 算数运算符

![09](/images/js/01/09.png)

说明：

+ 递增(++)和递减(--)运算就是通过不断地加1或减1,然后把结果赋值给左侧，以实现改变自身结果的一种简洁方法

+ 递增和递减在运算之前都会试图转换值为数值类型,如果失败则返回 NaN。

+ 根据位置不同,可以分为4种运算方式
  - 前置递增(++n):先加一,再赋值
  - 后置递增(n++):先赋值,再加一
  - 前置递减(--n):先减一,再赋值
  - 后置递减(n--):先赋值,再减一

+ 一元运算符：一个操作数 ++ --

  前++(--)或者后++(--)都是自身+1(-1)再给自身赋值

  对于a，前++(--)和后++(--)都是自身+1(-1)再赋值给自己

  对于b，前++(--),a先+1(-1)赋值给自己后再参与后面的计算。后++(--)，要看后面的算式是否再次用到a，如果用到，才把之前的后++(--)算上。

```html
<!DOCTYPE html>
<html lang="en">
      <head>
          <meta charset="UTF-8">
          <title>Title</title>
      </head>
      <body>
          <script>
              // 无论是  ++a；  还是 a++；  都是让 a每次加1，如果两个代码都是独立运行，那么两个代码没有区别
              var a = 1;
              a ++;//a++是让a  每次加1
              a ++;//a++是让a  每次加1
              a ++;//a++是让a  每次加1
              console.log(a);

              var b = 1;
              ++ b;//让b每次加1
              ++ b;//让b每次加1
              ++ b;//让b每次加1
              ++ b;//让b每次加1
              console.log(b);

              //c++不是单独运行的时候，也就是有赋值操作的时候，那么是先执行赋值，然后再去加1
              //c++ 就是先赋值 后加1
              var c = 2;
              var d = c ++;
              console.log(c);
              console.log(d);

              //++c  先加一 后赋值
              var c = 2;
              var d = ++ c;
              console.log(c);
              console.log(d);
          </script>
      </body>
</html>
```

练习：

1. ```js
   var a = 1;
   var b = ++a;
   console.log(a); a = 2	
   console.log(b);	b = 2
   ```

2. ```js
   var a = 1;
   var b = a++;
   console.log(a); a =2
   console.log(b); b =1
   ```

3. ```js
   var a = 1;
   var b = ++a + a;
   console.log(a); 2
   console.log(b);	4
   ```

4. ```js
   var a = 1;
   var b = ++a + ++a + a;
   console.log(a); 3
   console.log(b); 8
   ```

5. ```js
   var a = 1;
   var b = a + ++a + 1 + a + ++a;
   console.log(a);  3
   console.log(b); 9
   ```

6. ```js
   var a = 1;
   var b = a + a + ++a + 1 + a + ++a
   console.log(a); 3
   console.log(b); 10
   ```

7. ```js
   var a = 1;
   var b = a++ + 1 + a++;
   console.log(a);3
   console.log(b);4 
   ```

8. ```js
   var a = 1;
   var b = a++ + a++ + a + 1 + a++ + 1;
   console.log(a); 4
   console.log(b);11
   ```

9. ```js
   var a = 1;
   var b = a++ + ++a + a + a++;
   console.log(a);4
   console.log(b);10
   ```

10. ```js
    var b = ++a + a++ + a++ + a + ++a + a++ + a;
    console.log(a);
    console.log(b);
    ```
  ```

  ```

11. ```html
    <!DOCTYPE html>
    <html lang="en">
          <head>
              <meta charset="UTF-8">
              <title>Title</title>
          </head>
          <body>
              <script>
                  var a = 1;
                  b = a++ + (a++) + 1 + (++a) + (a++) + (++a) + a + (++a);
                  console.log(a);
                  console.log(b);
              </script>
          </body>
    </html>
    ```
  ```

### 2. 赋值运算符

![10](/images/js/01/10.png)

### 3. 字符串运算符

+ 运算符也可用于对字符串进行相加（concatenate，级联）。

  ```html
  a = "hello";
  b = "red romance";
  c = a + " " + b; 
  ```

+ += 赋值运算符也可用于相加（级联）字符串：

  ```html
  a = "ok ";
  a += "three man! go go go"; 
  ```

+ 相加两个数字，将返回和，但对一个数字和一个字符串相加将返回一个字符串：

  ```html
  x = 7 + 8;
  y = "7" + 8;
  z = "Hello" + 7;
  ```

### 4. 比较运算符

![11](/images/js/01/11.png)

### 5. 逻辑运算符

&& 当多个条件时,必须所有条件都是true,整个结果才是true,只要有一个条件时false,整个结果就是false

|| 当多个条件时,只要有一个条件是true,整个结果就是true,只有所有条件都是false时,整个结果才是false

! 取

![12](/images/js/01/12.png)

### 6. 逗号运算符

逗号运算符是二元运算符，它能够先执行运算符左侧的操作数，然后再执行右侧的操作数，最后返回右侧操作数的值。

```html
var a = 1,b = 2,c = 3,d = 4;
```

等价于

```html
var a = 1;
var b = 2;
var c = 3;
var d = 4;
```

练习：观察结果

```
a = (b = 1,c = 2);
console.log(a);
console.log(b); 
console.log(c); 

```

```html
a = b = 1,c = 2;
console.log(a);  
console.log(b);  
console.log(c);  
```
### 7. 特殊情况:比较不同的类型

如果将字符串与数字进行比较，那么在做比较时 JavaScript 会把字符串转换为数值。空字符串将被转换为 0。非数值字符串将被转换为始终为 false 的 NaN。

![13](/images/js/01/13.png)

### 8. 案例练习

+ 优先级

![17](/images/js/01/17.png)

+ 任意数据类型和NaN做数学运算,结果都是NaN,但是注意只要是字符串在和任意数据类型做相加+的运算,都是字符串拼接。
  字符串类型的数据:在进行数学运算(- * / %)时,会先将自身隐式转换(Number)成数值类型再进行计算
  在进行+操作时,是字符串的拼接

  ```js
  console.log('2' - '1')；
  console.log('2' - 1)；
  console.log('2' * 1)；
  console.log('2' / 3)；
  猜测一下取余结果的符号和除数，被除数哪个有关？
  console.log('2' % 3)；
  console.log('2' + '1')；
  console.log('1' + 3)；
  console.log('2' - '嘿嘿')；
  console.log('1' - '2abc')；
  console.log('嘿嘿' + '1a')； 
  console.log('嘿嘿' + NaN)；
  console.log('嘿嘿' + 5 * '6')； 
  console.log(('嘿嘿' + 5) * '6')； 
  ```

+ 布尔类型的数据:在进行数学运算(+ - * / %)时,会先将自身隐式转换(Number)成数值类型再进行计算

  ```js
  console.log(true + true); 
  console.log(true + 5); 
  console.log(true + '8'); 
  console.log(true - '8');
  console.log(false - 3);
  console.log(false - 3 * '哈哈');
  ```

+ 未定义类型的数据:在进行数学运算(+ - * / %)时,会先将自身隐式转换(Number)成数值类型再进行计算

  ```js
  console.log(undefined + undefined);
  console.log(undefined + 1);
  console.log(undefined + '5' + '哈哈');
  ```

+ 空类型的数据:在进行数学运算(+ - * / %)时,会先将自身隐式转换(Number)成数值 类型再进行计算

  ```js
  console.log(null + true); 
  console.log(null + 5);
  console.log('null' + (null - 3) + undefined);
  ```

+ 任意数据类型在进行关系运算时,会先将自身隐式转换(Number)成数值,在进行比较字符串与字符串之间的比较< > <= >=,比较的是ascii码,一位一位的去比

  ```js
  console.log(5 > 3);
  console.log(5 > '3');
  console.log('5' < true);
  console.log(5 > '6哈哈');
  console.log('a' < 'ab');
  console.log('ac' > 'ab');
  console.log('ab' < 'bz');
  // console.log(NaN < NaN)
  console.log('100' < 'a');
  console.log('5' == 5);
  console.log(1 == true);
  console.log(1 === true);
  console.log(0 == false);
  console.log(null < 1);

  //特殊的
  console.log(null == 0);
  console.log(null == ' ');
  console.log(null == '');
  console.log(null == false);
  console.log(null == undefined);
  ```

+ 练习题

  ```js
  console.log(undefined + null * '-10' + 100 > 90); 

  console.log(null * undefined + null + '嘿嘿');

  console.log(true + 'undefined' - undefined + '5');

  console.log((5 + true > true) + 5 > true);

  console.log(!true - '5' + 8 + parseInt('4嘿嘿'));

  console.log((!false - !null) * parseInt('3.14') + '');
  ```

+ 规则: 数学运算转Number, 字符串与任意类型数据相加都是拼接

  ​          关系运算转Number,字符串与字符串转Ascii码

  ​          逻辑运算转Boolean

  短路表达式:

  ​	&& 与 如果前面的表达式结果是true,返回的是后面表达式的数据，如果前面的表达式结果是false,直接返回数据

  ​	|| 或 如果前面的表达式是ture,直接返回数据，如果前面的表达式是false,返回的是后面表达式的数据

  ​	!  取反  

  ```js
  console.log(5 > 3 && 5 > 4);
  var a = 5 > 3 && 5 > 4 && 5 > 6;
  console.log(a);
  console.log(5 > 3 && 5 < 4 && 5 > 6);
  console.log(5 > 3 || 5 > 6);
  console.log(5 < 3 || 5 < 6 || 5 < 8);
  console.log(5 && 8);
  console.log(Boolean(5) && Boolean(8));
  console.log(null && '红浪漫');
  console.log(5 + 3 && 5 + 4);
  console.log(true == 5 > 3);
  console.log('' && NaN);
  // 作业
  console.log(' ' && NaN);
  console.log('红浪漫' && 10 + false && '张三');

  console.log(' ' && 10 + '红浪漫' && 5 > null);

  console.log(' ' && 10 - '红浪漫' && 1.3245644564464 + 2.14335334533553 + 32.433433533535);

  console.log(5 || 3);

  console.log(' ' || 10 + '红浪漫' || 5 > null);

  console.log('' || 10 - '红浪漫' || 5 > null);

  var b;
  console.log(5 - undefined || 10 + undefined * null || 5 * b);

  console.log(!(5 > 3));
  console.log(!5);
  console.log(!'哈哈');
  console.log(!undefined);
  console.log(!5 > 3);

  console.log(!'' + 5 + !null); 

  console.log(5 || 3 && '哈哈');
  console.log((5 || 3) && '哈哈');

  var f;
  console.log(!'红浪漫' + NaN || !10 + null * '5' && '8' * !f);

  console.log(' ' + true && !('红浪漫' - 8) || ' ' - 1 && !undefined + null); 

  console.log(!Number(' ') + true && Boolean('红浪漫') - 8 || ' ' - 1 && !undefined+ !(5+ 3));

  ```



